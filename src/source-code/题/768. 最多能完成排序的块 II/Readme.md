# 解法1
## 思路
观察排序后的数组，和被分隔后的数组。每块被分隔后的数组中各个数字出现的频次，和排序后的数组一定是一致的。
因此再排序数组中，每个数字出现其频次 `+1`，在原始数组中每个数字出现其频次 `-1`，如果出现各个数字的频次都为 0 时，则说明此时可以进行一次分割

## 代码
`index.ts`

## 复杂度
时间复杂度：数组的排序 O(NlogN)
空间复杂度：多了一个排序数组 O(N)

# 解法2
## 思路
假设当前已经有了几个块，当加入新的数字后，可能会出现以下情况
- 新增数字大于最后一个块的最大值，则最后加入的数字自己可以成为新的区块
- 新增数字小于最后一个块的最大值，则需要将后面的区块融合，直到加入的数字大于前一个区块的最大值，或者只剩最后一个区块了

## 代码
`index.2.ts`

## 复杂度
时间复杂度：数组遍历一次 O(N)
空间复杂度：多了一个栈存储最大值 O(N)